---
title: Effective Java中文版(第2版)读书笔记总结之 一(目录)
date: 2018-01-03 14:08:46
tags: [Java, Effective-Java]
categories:
---

> 2018年了. 新的一年里, 总感觉需要做点什么, 才对得起芳华.

在去年底时, 自己正在读着 _Joshua Block_ 写的 "Effective Java 中文版(第2版)". 刚好在 github 上看到一篇有关这本书的读书笔记总结. [传送门](https://github.com/HugoMatilla/Effective-JAVA-Summary)  
这个作者的总结看上来挺好, 不过是英文版的. 我想着, 要不照着作者的总结思路, 自己也来个中文版的吧.

于是就有了这个 **_Effective Java中文版(第2版)读书笔记总结_** 的第一篇.

这个系列一共有11章, 其中第一章为目录.  
作为在新的一年里的首个学习任务, 希望我能早点完成它吧~  
(其实, 大部分的内容都是翻译自这个英文的总结项目, 当然其中某些地方也会加上自己的总结进去)

该系列总结的 github 地址(更新中ing): [Effective-Java-Summary-In-Chinese](https://github.com/Sai628/Effective-Java-Summary-In-Chinese)

<!-- more -->

<br/>


# 一. 目录
- [一. 目录](./2018-01-03-effective-java-summary-01-table-of-contents.html)
- [二. 创建和销毁对象](./2018-01-03-effective-java-summary-02-creating-and-destroying-objects.html)
    - [1. 考虑用静态工厂方法代替构造器](./2018-01-03-effective-java-summary-02-creating-and-destroying-objects.html#1-考虑用静态工厂方法代替构造器)
    - [2. 遇到多个构造器参数时要考虑用构建器](./2018-01-03-effective-java-summary-02-creating-and-destroying-objects.html#2-遇到多个构造器参数时要考虑用构建器)
    - [3. 用私有构造器或者枚举类型强化 _Singleton_ 属性](./2018-01-03-effective-java-summary-02-creating-and-destroying-objects.html#3-用私有构造器或者枚举类型强化-Singleton-属性)
    - [4. 通过私有构造器强化不可实例化的能力](./2018-01-03-effective-java-summary-02-creating-and-destroying-objects.html#4-通过私有构造器强化不可实例化的能力)
    - [5. 避免创建不必要的对象](./2018-01-03-effective-java-summary-02-creating-and-destroying-objects.html#5-避免创建不必要的对象)
    - [6. 消除过期的对象引用](./2018-01-03-effective-java-summary-02-creating-and-destroying-objects.html#6-消除过期的对象引用)
    - [7. 避免使用终结方法](./2018-01-03-effective-java-summary-02-creating-and-destroying-objects.html#7-避免使用终结方法)
- [三. 对于所有对象都通用的方法](./2018-01-03-effective-java-summary-03-methods-common-to-all-objects.html)
    - [8. 覆盖 _equals_ 时请遵守通用约定](./2018-01-03-effective-java-summary-03-methods-common-to-all-objects.html#8-覆盖-equals-时请遵守通用约定)
    - [9. 覆盖 _equals_ 时总要覆盖 _hashCode_](./2018-01-03-effective-java-summary-03-methods-common-to-all-objects.html#9-覆盖-equals-时总要覆盖-hashCode)
    - [10. 始终要覆盖 _toString_](./2018-01-03-effective-java-summary-03-methods-common-to-all-objects.html#10-始终要覆盖-toString)
    - [11. 谨慎地覆盖 _clone_](./2018-01-03-effective-java-summary-03-methods-common-to-all-objects.html#11-谨慎地覆盖-clone)
    - [12. 考虑实现 _Comparable_ 接口](./2018-01-03-effective-java-summary-03-methods-common-to-all-objects.html#12-考虑实现-Comparable-接口)
- [四. 类和接口](#四-类和接口)
    - [13. 使类和成员的可访问性最小化](#13-使类和成员的可访问性最小化)
    - [14. 在公有类中使用访问方法而非公有域](#14-在公有类中使用访问方法而非公有域)
    - [15. 使可变性最小化](#15-使可变性最小化)
    - [16. 复合优于继承](#16-复合优于继承)
    - [17. 要么为继承而设计, 并提供文档说明, 要么就禁止继承](#17-要么为继承而设计-并提供文档说明-要么就禁止继承)
    - [18. 接口优于抽象类](#18-接口优于抽象类)
    - [19. 接口只用于定义类型](#19-接口只用于定义类型)
    - [20. 类层次优于标签类](#20-类层次优于标签类)
    - [21. 用函数对象表示策略](#21-用函数对象表示策略)
    - [22. 优先考虑静态成员类](#22-优先考虑静态成员类)
- [五. 泛型](#五-泛型)
    - [23. 请不要在新代码中使用原生态类型](#23-请不要在新代码中使用原生态类型)
    - [24. 消除非受检警告](#24-消除非受检警告)
    - [25. 列表优先于数组](#25-列表优先于数组)
    - [26. 优先考虑泛型](#26-优先考虑泛型)
    - [27. 优先考虑泛型方法](#27-优先考虑泛型方法)
    - [28. 利用有限制通配符来提升API的灵活性](#28-利用有限制通配符来提升api的灵活性)
    - [29. 优先考虑类型安全的异构容器](#29-优先考虑类型安全的异构容器)
- [六. 枚举和注解](#六-枚举和注解)
    - [30. 用 _enum_ 代替 _int_ 常量](#30-用-enum-代替-int-常量)
    - [31. 用实例域代替序数](#31-用实例域代替序数)
    - [32. 用 _EnumSet_ 代替位域](#32-用-enumset-代替位域)
    - [33. 用 _EnumMap_ 代替序数索引](#33-用-enummap-代替序数索引)
    - [34. 用接口模拟可伸缩的枚举](#34-用接口模拟可伸缩的枚举)
    - [35. 注解优先于命名模式](#35-注解优先于命名模式)
    - [36. 坚持使用 _Override_ 注解](#36-坚持使用-override-注解)
    - [37. 用标记接口定义类型](#37-用标记接口定义类型)
- [七. 方法](#七-方法)
    - [38. 检查参数的有效性](#38-检查参数的有效性)
    - [39. 必要时进行保护性拷贝](#39-必要时进行保护性拷贝)
    - [40. 谨慎设计方法签名](#40-谨慎设计方法签名)
    - [41. 慎用重载](#41-慎用重载)
    - [42. 慎用可变参数](#42-慎用可变参数)
    - [43. 返回零长度的数组或者集合, 而不是 _null_](#43-返回零长度的数组或者集合-而不是-null)
    - [44. 为所有导出的API元素编写文档注释](#44-为所有导出的api元素编写文档注释)
- [八. 通用程序设计](#八-通用程序设计)
    - [45. 将局部变量的作用域最小化](#45-将局部变量的作用域最小化)
    - [46. _for-each_ 循环优先于传统的 _for_ 循环](#46-for-each-循环优先于传统的-for-循环)
    - [47. 了解和使用类库](#47-了解和使用类库)
    - [48. 如果需要精确的答案, 请避免使用 _float_ 和 _double_](#48-如果需要精确的答案-请避免使用-float-和-double)
    - [49. 基本类型优先于装箱基本类型](#49-基本类型优先于装箱基本类型)
    - [50. 如果其它类型更适合, 则尽量避免使用字符串](#50-如果其它类型更适合-则尽量避免使用字符串)
    - [51. 当心字符串连接的性能](#51-当心字符串连接的性能)
    - [52. 通过接口引用对象](#52-通过接口引用对象)
    - [53. 接口优先于反射机制](#53-接口优先于反射机制)
    - [54. 谨慎地使用本地方法](#54-谨慎地使用本地方法)
    - [55. 谨慎地进行优化](#55-谨慎地进行优化)
    - [56. 遵守普遍接受的命令惯例](#56-遵守普遍接受的命令惯例)
- [九. 异常](#九-异常)
    - [57. 只针对异常的情况下才使用异常](#57-只针对异常的情况下才使用异常)
    - [58. 对可恢复的情况使用受检异常, 对编程错误使用运行时异常](#58-对可恢复的情况使用受检异常-对编程错误使用运行时异常)
    - [59. 避免不必要地使用受检的异常](#59-避免不必要地使用受检的异常)
    - [60. 优先使用标准的异常](#60-优先使用标准的异常)
    - [61. 抛出与抽象相对应的异常](#61-抛出与抽象相对应的异常)
    - [62. 每个方法抛出的异常都要有文档](#62-每个方法抛出的异常都要有文档)
    - [63. 在细节消息中包含能捕获失败的信息](#63-在细节消息中包含能捕获失败的信息)
    - [64. 努力使失败保持原子性](#64-努力使失败保持原子性)
    - [65. 不要忽略异常](#65-不要忽略异常)
- [十. 并发](#十-并发)
    - [66. 同步访问共享的可变数据](#66-同步访问共享的可变数据)
    - [67. 避免过度同步](#67-避免过度同步)
    - [68. _executor_ 和 _task_ 优先于线程](#68-executor-和-task-优先于线程)
    - [69. 并发工具优先于 _wait_ 和 _notify_](#69-并发工具优先于-wait-和-notify)
    - [70. 线程安全性的文档化](#70-线程安全性的文档化)
    - [71. 慎用延迟初始化](#71-慎用延迟初始化)
    - [72. 不要依赖于线程调度器](#72-不要依赖于线程调度器)
    - [73. 避免使用线程组](#73-避免使用线程组)
- [十一. 序列化](#十一-序列化)
    - [74. 谨慎地实现 _Serializable_ 接口](#74-谨慎地实现-serializable-接口)
    - [75. 考虑使用自定义的序列化形式](#75-考虑使用自定义的序列化形式)
    - [76. 保护性地编写 _readObject_ 方法](#76-保护性地编写-readobject-方法)
    - [77. 对于实例控制, 枚举类型优先于 _readResolve_](#77-对于实例控制-枚举类型优先于-readresolve)
    - [78. 考虑用序列化代理代替序列化实例](#78-考虑用序列化代理代替序列化实例)
